
00_Lec_1_Lab_1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000008a6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000018  00800060  000008a6  0000093a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000003  00800078  00800078  00000952  2**0
                  ALLOC
  3 .stab         00001500  00000000  00000000  00000954  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000015ae  00000000  00000000  00001e54  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e6 ea       	ldi	r30, 0xA6	; 166
  68:	f8 e0       	ldi	r31, 0x08	; 8
  6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
  70:	a8 37       	cpi	r26, 0x78	; 120
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
  76:	10 e0       	ldi	r17, 0x00	; 0
  78:	a8 e7       	ldi	r26, 0x78	; 120
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	ab 37       	cpi	r26, 0x7B	; 123
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 48 04 	call	0x890	; 0x890 <main>
  8a:	0c 94 51 04 	jmp	0x8a2	; 0x8a2 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <GPIO_initPin>:
static volatile uint8_t *port_registers[] = {&PORTA_REG, &PORTB_REG, &PORTC_REG,
                                             &PORTD_REG};
static volatile uint8_t *pin_registers[] = {&PINA_REG, &PINB_REG, &PINC_REG,
                                            &PIND_REG};

EN_GPIO_systemState_t GPIO_initPin(ST_GPIO_cfg_t const *ST_ptrPinInstance) {
  92:	df 93       	push	r29
  94:	cf 93       	push	r28
  96:	00 d0       	rcall	.+0      	; 0x98 <GPIO_initPin+0x6>
  98:	0f 92       	push	r0
  9a:	cd b7       	in	r28, 0x3d	; 61
  9c:	de b7       	in	r29, 0x3e	; 62
  9e:	9b 83       	std	Y+3, r25	; 0x03
  a0:	8a 83       	std	Y+2, r24	; 0x02
  EN_GPIO_systemState_t ret = GPIO_NOK;
  a2:	81 e0       	ldi	r24, 0x01	; 1
  a4:	89 83       	std	Y+1, r24	; 0x01
  if (PTR_NULL != ST_ptrPinInstance) {
  a6:	8a 81       	ldd	r24, Y+2	; 0x02
  a8:	9b 81       	ldd	r25, Y+3	; 0x03
  aa:	00 97       	sbiw	r24, 0x00	; 0
  ac:	b1 f0       	breq	.+44     	; 0xda <GPIO_initPin+0x48>
    ret = GPIO_changePinDir(ST_ptrPinInstance, ST_ptrPinInstance->pinDirection);
  ae:	ea 81       	ldd	r30, Y+2	; 0x02
  b0:	fb 81       	ldd	r31, Y+3	; 0x03
  b2:	22 81       	ldd	r18, Z+2	; 0x02
  b4:	8a 81       	ldd	r24, Y+2	; 0x02
  b6:	9b 81       	ldd	r25, Y+3	; 0x03
  b8:	62 2f       	mov	r22, r18
  ba:	0e 94 76 00 	call	0xec	; 0xec <GPIO_changePinDir>
  be:	89 83       	std	Y+1, r24	; 0x01
    if (GPIO_OK == ret) {
  c0:	89 81       	ldd	r24, Y+1	; 0x01
  c2:	88 23       	and	r24, r24
  c4:	61 f4       	brne	.+24     	; 0xde <GPIO_initPin+0x4c>
      ret =
  c6:	ea 81       	ldd	r30, Y+2	; 0x02
  c8:	fb 81       	ldd	r31, Y+3	; 0x03
  ca:	23 81       	ldd	r18, Z+3	; 0x03
  cc:	8a 81       	ldd	r24, Y+2	; 0x02
  ce:	9b 81       	ldd	r25, Y+3	; 0x03
  d0:	62 2f       	mov	r22, r18
  d2:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <GPIO_writePinLogic>
  d6:	89 83       	std	Y+1, r24	; 0x01
  d8:	02 c0       	rjmp	.+4      	; 0xde <GPIO_initPin+0x4c>
          GPIO_writePinLogic(ST_ptrPinInstance, ST_ptrPinInstance->logicOnPin);
    } else {
      /*Do Nothin*/
    }
  } else {
    ret = GPIO_NULL_PTR;
  da:	82 e0       	ldi	r24, 0x02	; 2
  dc:	89 83       	std	Y+1, r24	; 0x01
  }
  return ret;
  de:	89 81       	ldd	r24, Y+1	; 0x01
}
  e0:	0f 90       	pop	r0
  e2:	0f 90       	pop	r0
  e4:	0f 90       	pop	r0
  e6:	cf 91       	pop	r28
  e8:	df 91       	pop	r29
  ea:	08 95       	ret

000000ec <GPIO_changePinDir>:

EN_GPIO_systemState_t GPIO_changePinDir(ST_GPIO_cfg_t const *ST_ptrPinInstance,
                                        EN_GPIO_pinDir_t copyNewPinDir) {
  ec:	df 93       	push	r29
  ee:	cf 93       	push	r28
  f0:	00 d0       	rcall	.+0      	; 0xf2 <GPIO_changePinDir+0x6>
  f2:	00 d0       	rcall	.+0      	; 0xf4 <GPIO_changePinDir+0x8>
  f4:	00 d0       	rcall	.+0      	; 0xf6 <GPIO_changePinDir+0xa>
  f6:	cd b7       	in	r28, 0x3d	; 61
  f8:	de b7       	in	r29, 0x3e	; 62
  fa:	9b 83       	std	Y+3, r25	; 0x03
  fc:	8a 83       	std	Y+2, r24	; 0x02
  fe:	6c 83       	std	Y+4, r22	; 0x04
  EN_GPIO_systemState_t ret = GPIO_NOK;
 100:	81 e0       	ldi	r24, 0x01	; 1
 102:	89 83       	std	Y+1, r24	; 0x01
  if (PTR_NULL != ST_ptrPinInstance) {
 104:	8a 81       	ldd	r24, Y+2	; 0x02
 106:	9b 81       	ldd	r25, Y+3	; 0x03
 108:	00 97       	sbiw	r24, 0x00	; 0
 10a:	09 f4       	brne	.+2      	; 0x10e <GPIO_changePinDir+0x22>
 10c:	68 c0       	rjmp	.+208    	; 0x1de <GPIO_changePinDir+0xf2>
    switch (copyNewPinDir) {
 10e:	8c 81       	ldd	r24, Y+4	; 0x04
 110:	28 2f       	mov	r18, r24
 112:	30 e0       	ldi	r19, 0x00	; 0
 114:	3e 83       	std	Y+6, r19	; 0x06
 116:	2d 83       	std	Y+5, r18	; 0x05
 118:	8d 81       	ldd	r24, Y+5	; 0x05
 11a:	9e 81       	ldd	r25, Y+6	; 0x06
 11c:	00 97       	sbiw	r24, 0x00	; 0
 11e:	31 f0       	breq	.+12     	; 0x12c <GPIO_changePinDir+0x40>
 120:	2d 81       	ldd	r18, Y+5	; 0x05
 122:	3e 81       	ldd	r19, Y+6	; 0x06
 124:	21 30       	cpi	r18, 0x01	; 1
 126:	31 05       	cpc	r19, r1
 128:	71 f1       	breq	.+92     	; 0x186 <GPIO_changePinDir+0x9a>
 12a:	5b c0       	rjmp	.+182    	; 0x1e2 <GPIO_changePinDir+0xf6>
    case GPIO_INPUT: {
      CLR_BIT(*ddr_registers[ST_ptrPinInstance->portName],
 12c:	ea 81       	ldd	r30, Y+2	; 0x02
 12e:	fb 81       	ldd	r31, Y+3	; 0x03
 130:	80 81       	ld	r24, Z
 132:	88 2f       	mov	r24, r24
 134:	90 e0       	ldi	r25, 0x00	; 0
 136:	88 0f       	add	r24, r24
 138:	99 1f       	adc	r25, r25
 13a:	fc 01       	movw	r30, r24
 13c:	e0 5a       	subi	r30, 0xA0	; 160
 13e:	ff 4f       	sbci	r31, 0xFF	; 255
 140:	a0 81       	ld	r26, Z
 142:	b1 81       	ldd	r27, Z+1	; 0x01
 144:	ea 81       	ldd	r30, Y+2	; 0x02
 146:	fb 81       	ldd	r31, Y+3	; 0x03
 148:	80 81       	ld	r24, Z
 14a:	88 2f       	mov	r24, r24
 14c:	90 e0       	ldi	r25, 0x00	; 0
 14e:	88 0f       	add	r24, r24
 150:	99 1f       	adc	r25, r25
 152:	fc 01       	movw	r30, r24
 154:	e0 5a       	subi	r30, 0xA0	; 160
 156:	ff 4f       	sbci	r31, 0xFF	; 255
 158:	01 90       	ld	r0, Z+
 15a:	f0 81       	ld	r31, Z
 15c:	e0 2d       	mov	r30, r0
 15e:	80 81       	ld	r24, Z
 160:	48 2f       	mov	r20, r24
 162:	ea 81       	ldd	r30, Y+2	; 0x02
 164:	fb 81       	ldd	r31, Y+3	; 0x03
 166:	81 81       	ldd	r24, Z+1	; 0x01
 168:	28 2f       	mov	r18, r24
 16a:	30 e0       	ldi	r19, 0x00	; 0
 16c:	81 e0       	ldi	r24, 0x01	; 1
 16e:	90 e0       	ldi	r25, 0x00	; 0
 170:	02 2e       	mov	r0, r18
 172:	02 c0       	rjmp	.+4      	; 0x178 <GPIO_changePinDir+0x8c>
 174:	88 0f       	add	r24, r24
 176:	99 1f       	adc	r25, r25
 178:	0a 94       	dec	r0
 17a:	e2 f7       	brpl	.-8      	; 0x174 <GPIO_changePinDir+0x88>
 17c:	80 95       	com	r24
 17e:	84 23       	and	r24, r20
 180:	8c 93       	st	X, r24
              ST_ptrPinInstance->pinNumber);
      ret = GPIO_OK;
 182:	19 82       	std	Y+1, r1	; 0x01
 184:	2e c0       	rjmp	.+92     	; 0x1e2 <GPIO_changePinDir+0xf6>
      break;
    }
    case GPIO_OUTPUT: {
      SET_BIT(*ddr_registers[ST_ptrPinInstance->portName],
 186:	ea 81       	ldd	r30, Y+2	; 0x02
 188:	fb 81       	ldd	r31, Y+3	; 0x03
 18a:	80 81       	ld	r24, Z
 18c:	88 2f       	mov	r24, r24
 18e:	90 e0       	ldi	r25, 0x00	; 0
 190:	88 0f       	add	r24, r24
 192:	99 1f       	adc	r25, r25
 194:	fc 01       	movw	r30, r24
 196:	e0 5a       	subi	r30, 0xA0	; 160
 198:	ff 4f       	sbci	r31, 0xFF	; 255
 19a:	a0 81       	ld	r26, Z
 19c:	b1 81       	ldd	r27, Z+1	; 0x01
 19e:	ea 81       	ldd	r30, Y+2	; 0x02
 1a0:	fb 81       	ldd	r31, Y+3	; 0x03
 1a2:	80 81       	ld	r24, Z
 1a4:	88 2f       	mov	r24, r24
 1a6:	90 e0       	ldi	r25, 0x00	; 0
 1a8:	88 0f       	add	r24, r24
 1aa:	99 1f       	adc	r25, r25
 1ac:	fc 01       	movw	r30, r24
 1ae:	e0 5a       	subi	r30, 0xA0	; 160
 1b0:	ff 4f       	sbci	r31, 0xFF	; 255
 1b2:	01 90       	ld	r0, Z+
 1b4:	f0 81       	ld	r31, Z
 1b6:	e0 2d       	mov	r30, r0
 1b8:	80 81       	ld	r24, Z
 1ba:	48 2f       	mov	r20, r24
 1bc:	ea 81       	ldd	r30, Y+2	; 0x02
 1be:	fb 81       	ldd	r31, Y+3	; 0x03
 1c0:	81 81       	ldd	r24, Z+1	; 0x01
 1c2:	28 2f       	mov	r18, r24
 1c4:	30 e0       	ldi	r19, 0x00	; 0
 1c6:	81 e0       	ldi	r24, 0x01	; 1
 1c8:	90 e0       	ldi	r25, 0x00	; 0
 1ca:	02 2e       	mov	r0, r18
 1cc:	02 c0       	rjmp	.+4      	; 0x1d2 <GPIO_changePinDir+0xe6>
 1ce:	88 0f       	add	r24, r24
 1d0:	99 1f       	adc	r25, r25
 1d2:	0a 94       	dec	r0
 1d4:	e2 f7       	brpl	.-8      	; 0x1ce <GPIO_changePinDir+0xe2>
 1d6:	84 2b       	or	r24, r20
 1d8:	8c 93       	st	X, r24
              ST_ptrPinInstance->pinNumber);
      ret = GPIO_OK;
 1da:	19 82       	std	Y+1, r1	; 0x01
 1dc:	02 c0       	rjmp	.+4      	; 0x1e2 <GPIO_changePinDir+0xf6>
      break;
    }
    }
  } else {
    ret = GPIO_NULL_PTR;
 1de:	82 e0       	ldi	r24, 0x02	; 2
 1e0:	89 83       	std	Y+1, r24	; 0x01
  }
  return ret;
 1e2:	89 81       	ldd	r24, Y+1	; 0x01
}
 1e4:	26 96       	adiw	r28, 0x06	; 6
 1e6:	0f b6       	in	r0, 0x3f	; 63
 1e8:	f8 94       	cli
 1ea:	de bf       	out	0x3e, r29	; 62
 1ec:	0f be       	out	0x3f, r0	; 63
 1ee:	cd bf       	out	0x3d, r28	; 61
 1f0:	cf 91       	pop	r28
 1f2:	df 91       	pop	r29
 1f4:	08 95       	ret

000001f6 <GPIO_writePinLogic>:

EN_GPIO_systemState_t GPIO_writePinLogic(ST_GPIO_cfg_t const *ST_ptrPinInstance,
                                         EN_GPIO_pinLogic_t copyNewPinLogic) {
 1f6:	df 93       	push	r29
 1f8:	cf 93       	push	r28
 1fa:	00 d0       	rcall	.+0      	; 0x1fc <GPIO_writePinLogic+0x6>
 1fc:	00 d0       	rcall	.+0      	; 0x1fe <GPIO_writePinLogic+0x8>
 1fe:	00 d0       	rcall	.+0      	; 0x200 <GPIO_writePinLogic+0xa>
 200:	cd b7       	in	r28, 0x3d	; 61
 202:	de b7       	in	r29, 0x3e	; 62
 204:	9b 83       	std	Y+3, r25	; 0x03
 206:	8a 83       	std	Y+2, r24	; 0x02
 208:	6c 83       	std	Y+4, r22	; 0x04
  EN_GPIO_systemState_t ret = GPIO_NOK;
 20a:	81 e0       	ldi	r24, 0x01	; 1
 20c:	89 83       	std	Y+1, r24	; 0x01
  if (PTR_NULL != ST_ptrPinInstance) {
 20e:	8a 81       	ldd	r24, Y+2	; 0x02
 210:	9b 81       	ldd	r25, Y+3	; 0x03
 212:	00 97       	sbiw	r24, 0x00	; 0
 214:	09 f4       	brne	.+2      	; 0x218 <GPIO_writePinLogic+0x22>
 216:	68 c0       	rjmp	.+208    	; 0x2e8 <GPIO_writePinLogic+0xf2>
    switch (copyNewPinLogic) {
 218:	8c 81       	ldd	r24, Y+4	; 0x04
 21a:	28 2f       	mov	r18, r24
 21c:	30 e0       	ldi	r19, 0x00	; 0
 21e:	3e 83       	std	Y+6, r19	; 0x06
 220:	2d 83       	std	Y+5, r18	; 0x05
 222:	8d 81       	ldd	r24, Y+5	; 0x05
 224:	9e 81       	ldd	r25, Y+6	; 0x06
 226:	00 97       	sbiw	r24, 0x00	; 0
 228:	31 f0       	breq	.+12     	; 0x236 <GPIO_writePinLogic+0x40>
 22a:	2d 81       	ldd	r18, Y+5	; 0x05
 22c:	3e 81       	ldd	r19, Y+6	; 0x06
 22e:	21 30       	cpi	r18, 0x01	; 1
 230:	31 05       	cpc	r19, r1
 232:	71 f1       	breq	.+92     	; 0x290 <GPIO_writePinLogic+0x9a>
 234:	5b c0       	rjmp	.+182    	; 0x2ec <GPIO_writePinLogic+0xf6>
    case GPIO_LOW: {
      CLR_BIT(*port_registers[ST_ptrPinInstance->portName],
 236:	ea 81       	ldd	r30, Y+2	; 0x02
 238:	fb 81       	ldd	r31, Y+3	; 0x03
 23a:	80 81       	ld	r24, Z
 23c:	88 2f       	mov	r24, r24
 23e:	90 e0       	ldi	r25, 0x00	; 0
 240:	88 0f       	add	r24, r24
 242:	99 1f       	adc	r25, r25
 244:	fc 01       	movw	r30, r24
 246:	e8 59       	subi	r30, 0x98	; 152
 248:	ff 4f       	sbci	r31, 0xFF	; 255
 24a:	a0 81       	ld	r26, Z
 24c:	b1 81       	ldd	r27, Z+1	; 0x01
 24e:	ea 81       	ldd	r30, Y+2	; 0x02
 250:	fb 81       	ldd	r31, Y+3	; 0x03
 252:	80 81       	ld	r24, Z
 254:	88 2f       	mov	r24, r24
 256:	90 e0       	ldi	r25, 0x00	; 0
 258:	88 0f       	add	r24, r24
 25a:	99 1f       	adc	r25, r25
 25c:	fc 01       	movw	r30, r24
 25e:	e8 59       	subi	r30, 0x98	; 152
 260:	ff 4f       	sbci	r31, 0xFF	; 255
 262:	01 90       	ld	r0, Z+
 264:	f0 81       	ld	r31, Z
 266:	e0 2d       	mov	r30, r0
 268:	80 81       	ld	r24, Z
 26a:	48 2f       	mov	r20, r24
 26c:	ea 81       	ldd	r30, Y+2	; 0x02
 26e:	fb 81       	ldd	r31, Y+3	; 0x03
 270:	81 81       	ldd	r24, Z+1	; 0x01
 272:	28 2f       	mov	r18, r24
 274:	30 e0       	ldi	r19, 0x00	; 0
 276:	81 e0       	ldi	r24, 0x01	; 1
 278:	90 e0       	ldi	r25, 0x00	; 0
 27a:	02 2e       	mov	r0, r18
 27c:	02 c0       	rjmp	.+4      	; 0x282 <GPIO_writePinLogic+0x8c>
 27e:	88 0f       	add	r24, r24
 280:	99 1f       	adc	r25, r25
 282:	0a 94       	dec	r0
 284:	e2 f7       	brpl	.-8      	; 0x27e <GPIO_writePinLogic+0x88>
 286:	80 95       	com	r24
 288:	84 23       	and	r24, r20
 28a:	8c 93       	st	X, r24
              ST_ptrPinInstance->pinNumber);
      ret = GPIO_OK;
 28c:	19 82       	std	Y+1, r1	; 0x01
 28e:	2e c0       	rjmp	.+92     	; 0x2ec <GPIO_writePinLogic+0xf6>
      break;
    }
    case GPIO_HIGH: {
      SET_BIT(*port_registers[ST_ptrPinInstance->portName],
 290:	ea 81       	ldd	r30, Y+2	; 0x02
 292:	fb 81       	ldd	r31, Y+3	; 0x03
 294:	80 81       	ld	r24, Z
 296:	88 2f       	mov	r24, r24
 298:	90 e0       	ldi	r25, 0x00	; 0
 29a:	88 0f       	add	r24, r24
 29c:	99 1f       	adc	r25, r25
 29e:	fc 01       	movw	r30, r24
 2a0:	e8 59       	subi	r30, 0x98	; 152
 2a2:	ff 4f       	sbci	r31, 0xFF	; 255
 2a4:	a0 81       	ld	r26, Z
 2a6:	b1 81       	ldd	r27, Z+1	; 0x01
 2a8:	ea 81       	ldd	r30, Y+2	; 0x02
 2aa:	fb 81       	ldd	r31, Y+3	; 0x03
 2ac:	80 81       	ld	r24, Z
 2ae:	88 2f       	mov	r24, r24
 2b0:	90 e0       	ldi	r25, 0x00	; 0
 2b2:	88 0f       	add	r24, r24
 2b4:	99 1f       	adc	r25, r25
 2b6:	fc 01       	movw	r30, r24
 2b8:	e8 59       	subi	r30, 0x98	; 152
 2ba:	ff 4f       	sbci	r31, 0xFF	; 255
 2bc:	01 90       	ld	r0, Z+
 2be:	f0 81       	ld	r31, Z
 2c0:	e0 2d       	mov	r30, r0
 2c2:	80 81       	ld	r24, Z
 2c4:	48 2f       	mov	r20, r24
 2c6:	ea 81       	ldd	r30, Y+2	; 0x02
 2c8:	fb 81       	ldd	r31, Y+3	; 0x03
 2ca:	81 81       	ldd	r24, Z+1	; 0x01
 2cc:	28 2f       	mov	r18, r24
 2ce:	30 e0       	ldi	r19, 0x00	; 0
 2d0:	81 e0       	ldi	r24, 0x01	; 1
 2d2:	90 e0       	ldi	r25, 0x00	; 0
 2d4:	02 2e       	mov	r0, r18
 2d6:	02 c0       	rjmp	.+4      	; 0x2dc <GPIO_writePinLogic+0xe6>
 2d8:	88 0f       	add	r24, r24
 2da:	99 1f       	adc	r25, r25
 2dc:	0a 94       	dec	r0
 2de:	e2 f7       	brpl	.-8      	; 0x2d8 <GPIO_writePinLogic+0xe2>
 2e0:	84 2b       	or	r24, r20
 2e2:	8c 93       	st	X, r24
              ST_ptrPinInstance->pinNumber);
      ret = GPIO_OK;
 2e4:	19 82       	std	Y+1, r1	; 0x01
 2e6:	02 c0       	rjmp	.+4      	; 0x2ec <GPIO_writePinLogic+0xf6>
      break;
    }
    }
  } else {
    ret = GPIO_NULL_PTR;
 2e8:	82 e0       	ldi	r24, 0x02	; 2
 2ea:	89 83       	std	Y+1, r24	; 0x01
  }
  return ret;
 2ec:	89 81       	ldd	r24, Y+1	; 0x01
}
 2ee:	26 96       	adiw	r28, 0x06	; 6
 2f0:	0f b6       	in	r0, 0x3f	; 63
 2f2:	f8 94       	cli
 2f4:	de bf       	out	0x3e, r29	; 62
 2f6:	0f be       	out	0x3f, r0	; 63
 2f8:	cd bf       	out	0x3d, r28	; 61
 2fa:	cf 91       	pop	r28
 2fc:	df 91       	pop	r29
 2fe:	08 95       	ret

00000300 <GPIO_readPinLogic>:

EN_GPIO_systemState_t
GPIO_readPinLogic(ST_GPIO_cfg_t const *ST_ptrPinInstance,
                  EN_GPIO_pinLogic_t *retCurrentPinLogic) {
 300:	df 93       	push	r29
 302:	cf 93       	push	r28
 304:	00 d0       	rcall	.+0      	; 0x306 <GPIO_readPinLogic+0x6>
 306:	00 d0       	rcall	.+0      	; 0x308 <GPIO_readPinLogic+0x8>
 308:	0f 92       	push	r0
 30a:	cd b7       	in	r28, 0x3d	; 61
 30c:	de b7       	in	r29, 0x3e	; 62
 30e:	9b 83       	std	Y+3, r25	; 0x03
 310:	8a 83       	std	Y+2, r24	; 0x02
 312:	7d 83       	std	Y+5, r23	; 0x05
 314:	6c 83       	std	Y+4, r22	; 0x04
  EN_GPIO_systemState_t ret = GPIO_NOK;
 316:	81 e0       	ldi	r24, 0x01	; 1
 318:	89 83       	std	Y+1, r24	; 0x01
  if (PTR_NULL != ST_ptrPinInstance) {
 31a:	8a 81       	ldd	r24, Y+2	; 0x02
 31c:	9b 81       	ldd	r25, Y+3	; 0x03
 31e:	00 97       	sbiw	r24, 0x00	; 0
 320:	11 f1       	breq	.+68     	; 0x366 <GPIO_readPinLogic+0x66>
    *retCurrentPinLogic = GET_BIT(*pin_registers[ST_ptrPinInstance->portName],
 322:	ea 81       	ldd	r30, Y+2	; 0x02
 324:	fb 81       	ldd	r31, Y+3	; 0x03
 326:	80 81       	ld	r24, Z
 328:	88 2f       	mov	r24, r24
 32a:	90 e0       	ldi	r25, 0x00	; 0
 32c:	88 0f       	add	r24, r24
 32e:	99 1f       	adc	r25, r25
 330:	fc 01       	movw	r30, r24
 332:	e0 59       	subi	r30, 0x90	; 144
 334:	ff 4f       	sbci	r31, 0xFF	; 255
 336:	01 90       	ld	r0, Z+
 338:	f0 81       	ld	r31, Z
 33a:	e0 2d       	mov	r30, r0
 33c:	80 81       	ld	r24, Z
 33e:	28 2f       	mov	r18, r24
 340:	30 e0       	ldi	r19, 0x00	; 0
 342:	ea 81       	ldd	r30, Y+2	; 0x02
 344:	fb 81       	ldd	r31, Y+3	; 0x03
 346:	81 81       	ldd	r24, Z+1	; 0x01
 348:	88 2f       	mov	r24, r24
 34a:	90 e0       	ldi	r25, 0x00	; 0
 34c:	a9 01       	movw	r20, r18
 34e:	02 c0       	rjmp	.+4      	; 0x354 <GPIO_readPinLogic+0x54>
 350:	55 95       	asr	r21
 352:	47 95       	ror	r20
 354:	8a 95       	dec	r24
 356:	e2 f7       	brpl	.-8      	; 0x350 <GPIO_readPinLogic+0x50>
 358:	ca 01       	movw	r24, r20
 35a:	81 70       	andi	r24, 0x01	; 1
 35c:	ec 81       	ldd	r30, Y+4	; 0x04
 35e:	fd 81       	ldd	r31, Y+5	; 0x05
 360:	80 83       	st	Z, r24
                                  ST_ptrPinInstance->pinNumber);
    ret = GPIO_OK;
 362:	19 82       	std	Y+1, r1	; 0x01
 364:	02 c0       	rjmp	.+4      	; 0x36a <GPIO_readPinLogic+0x6a>
  } else {
    ret = GPIO_NULL_PTR;
 366:	82 e0       	ldi	r24, 0x02	; 2
 368:	89 83       	std	Y+1, r24	; 0x01
  }
  return ret;
 36a:	89 81       	ldd	r24, Y+1	; 0x01
}
 36c:	0f 90       	pop	r0
 36e:	0f 90       	pop	r0
 370:	0f 90       	pop	r0
 372:	0f 90       	pop	r0
 374:	0f 90       	pop	r0
 376:	cf 91       	pop	r28
 378:	df 91       	pop	r29
 37a:	08 95       	ret

0000037c <GPIO_togglePinLogic>:

EN_GPIO_systemState_t
GPIO_togglePinLogic(ST_GPIO_cfg_t const *ST_ptrPinInstance) {
 37c:	df 93       	push	r29
 37e:	cf 93       	push	r28
 380:	00 d0       	rcall	.+0      	; 0x382 <GPIO_togglePinLogic+0x6>
 382:	0f 92       	push	r0
 384:	cd b7       	in	r28, 0x3d	; 61
 386:	de b7       	in	r29, 0x3e	; 62
 388:	9b 83       	std	Y+3, r25	; 0x03
 38a:	8a 83       	std	Y+2, r24	; 0x02
  EN_GPIO_systemState_t ret = GPIO_NOK;
 38c:	81 e0       	ldi	r24, 0x01	; 1
 38e:	89 83       	std	Y+1, r24	; 0x01
  if (PTR_NULL != ST_ptrPinInstance) {
 390:	8a 81       	ldd	r24, Y+2	; 0x02
 392:	9b 81       	ldd	r25, Y+3	; 0x03
 394:	00 97       	sbiw	r24, 0x00	; 0
 396:	61 f1       	breq	.+88     	; 0x3f0 <GPIO_togglePinLogic+0x74>
    TOG_BIT(*port_registers[ST_ptrPinInstance->portName],
 398:	ea 81       	ldd	r30, Y+2	; 0x02
 39a:	fb 81       	ldd	r31, Y+3	; 0x03
 39c:	80 81       	ld	r24, Z
 39e:	88 2f       	mov	r24, r24
 3a0:	90 e0       	ldi	r25, 0x00	; 0
 3a2:	88 0f       	add	r24, r24
 3a4:	99 1f       	adc	r25, r25
 3a6:	fc 01       	movw	r30, r24
 3a8:	e8 59       	subi	r30, 0x98	; 152
 3aa:	ff 4f       	sbci	r31, 0xFF	; 255
 3ac:	a0 81       	ld	r26, Z
 3ae:	b1 81       	ldd	r27, Z+1	; 0x01
 3b0:	ea 81       	ldd	r30, Y+2	; 0x02
 3b2:	fb 81       	ldd	r31, Y+3	; 0x03
 3b4:	80 81       	ld	r24, Z
 3b6:	88 2f       	mov	r24, r24
 3b8:	90 e0       	ldi	r25, 0x00	; 0
 3ba:	88 0f       	add	r24, r24
 3bc:	99 1f       	adc	r25, r25
 3be:	fc 01       	movw	r30, r24
 3c0:	e8 59       	subi	r30, 0x98	; 152
 3c2:	ff 4f       	sbci	r31, 0xFF	; 255
 3c4:	01 90       	ld	r0, Z+
 3c6:	f0 81       	ld	r31, Z
 3c8:	e0 2d       	mov	r30, r0
 3ca:	80 81       	ld	r24, Z
 3cc:	48 2f       	mov	r20, r24
 3ce:	ea 81       	ldd	r30, Y+2	; 0x02
 3d0:	fb 81       	ldd	r31, Y+3	; 0x03
 3d2:	81 81       	ldd	r24, Z+1	; 0x01
 3d4:	28 2f       	mov	r18, r24
 3d6:	30 e0       	ldi	r19, 0x00	; 0
 3d8:	81 e0       	ldi	r24, 0x01	; 1
 3da:	90 e0       	ldi	r25, 0x00	; 0
 3dc:	02 2e       	mov	r0, r18
 3de:	02 c0       	rjmp	.+4      	; 0x3e4 <GPIO_togglePinLogic+0x68>
 3e0:	88 0f       	add	r24, r24
 3e2:	99 1f       	adc	r25, r25
 3e4:	0a 94       	dec	r0
 3e6:	e2 f7       	brpl	.-8      	; 0x3e0 <GPIO_togglePinLogic+0x64>
 3e8:	84 27       	eor	r24, r20
 3ea:	8c 93       	st	X, r24
            ST_ptrPinInstance->pinNumber);
    ret = GPIO_OK;
 3ec:	19 82       	std	Y+1, r1	; 0x01
 3ee:	02 c0       	rjmp	.+4      	; 0x3f4 <GPIO_togglePinLogic+0x78>
  } else {
    ret = GPIO_NULL_PTR;
 3f0:	82 e0       	ldi	r24, 0x02	; 2
 3f2:	89 83       	std	Y+1, r24	; 0x01
  }

  return ret;
 3f4:	89 81       	ldd	r24, Y+1	; 0x01
}
 3f6:	0f 90       	pop	r0
 3f8:	0f 90       	pop	r0
 3fa:	0f 90       	pop	r0
 3fc:	cf 91       	pop	r28
 3fe:	df 91       	pop	r29
 400:	08 95       	ret

00000402 <GPIO_initPort>:

EN_GPIO_systemState_t GPIO_initPort(EN_GPIO_mcuPorts_t copyPortName,
                                    EN_GPIO_pinDir_t copyPortDir,
                                    EN_GPIO_pinLogic_t copyPortLogic) {
 402:	df 93       	push	r29
 404:	cf 93       	push	r28
 406:	cd b7       	in	r28, 0x3d	; 61
 408:	de b7       	in	r29, 0x3e	; 62
 40a:	28 97       	sbiw	r28, 0x08	; 8
 40c:	0f b6       	in	r0, 0x3f	; 63
 40e:	f8 94       	cli
 410:	de bf       	out	0x3e, r29	; 62
 412:	0f be       	out	0x3f, r0	; 63
 414:	cd bf       	out	0x3d, r28	; 61
 416:	8a 83       	std	Y+2, r24	; 0x02
 418:	6b 83       	std	Y+3, r22	; 0x03
 41a:	4c 83       	std	Y+4, r20	; 0x04
  EN_GPIO_systemState_t ret = GPIO_NOK;
 41c:	81 e0       	ldi	r24, 0x01	; 1
 41e:	89 83       	std	Y+1, r24	; 0x01

  switch (copyPortDir) {
 420:	8b 81       	ldd	r24, Y+3	; 0x03
 422:	28 2f       	mov	r18, r24
 424:	30 e0       	ldi	r19, 0x00	; 0
 426:	38 87       	std	Y+8, r19	; 0x08
 428:	2f 83       	std	Y+7, r18	; 0x07
 42a:	8f 81       	ldd	r24, Y+7	; 0x07
 42c:	98 85       	ldd	r25, Y+8	; 0x08
 42e:	00 97       	sbiw	r24, 0x00	; 0
 430:	31 f0       	breq	.+12     	; 0x43e <GPIO_initPort+0x3c>
 432:	2f 81       	ldd	r18, Y+7	; 0x07
 434:	38 85       	ldd	r19, Y+8	; 0x08
 436:	21 30       	cpi	r18, 0x01	; 1
 438:	31 05       	cpc	r19, r1
 43a:	79 f0       	breq	.+30     	; 0x45a <GPIO_initPort+0x58>
 43c:	1c c0       	rjmp	.+56     	; 0x476 <GPIO_initPort+0x74>
  case GPIO_INPUT: {
    *ddr_registers[copyPortName] = 0x00;
 43e:	8a 81       	ldd	r24, Y+2	; 0x02
 440:	88 2f       	mov	r24, r24
 442:	90 e0       	ldi	r25, 0x00	; 0
 444:	88 0f       	add	r24, r24
 446:	99 1f       	adc	r25, r25
 448:	fc 01       	movw	r30, r24
 44a:	e0 5a       	subi	r30, 0xA0	; 160
 44c:	ff 4f       	sbci	r31, 0xFF	; 255
 44e:	01 90       	ld	r0, Z+
 450:	f0 81       	ld	r31, Z
 452:	e0 2d       	mov	r30, r0
 454:	10 82       	st	Z, r1
    ret = GPIO_OK;
 456:	19 82       	std	Y+1, r1	; 0x01
 458:	0e c0       	rjmp	.+28     	; 0x476 <GPIO_initPort+0x74>
    break;
  }
  case GPIO_OUTPUT: {
    *ddr_registers[copyPortName] = 0xFF;
 45a:	8a 81       	ldd	r24, Y+2	; 0x02
 45c:	88 2f       	mov	r24, r24
 45e:	90 e0       	ldi	r25, 0x00	; 0
 460:	88 0f       	add	r24, r24
 462:	99 1f       	adc	r25, r25
 464:	fc 01       	movw	r30, r24
 466:	e0 5a       	subi	r30, 0xA0	; 160
 468:	ff 4f       	sbci	r31, 0xFF	; 255
 46a:	01 90       	ld	r0, Z+
 46c:	f0 81       	ld	r31, Z
 46e:	e0 2d       	mov	r30, r0
 470:	8f ef       	ldi	r24, 0xFF	; 255
 472:	80 83       	st	Z, r24
    ret = GPIO_OK;
 474:	19 82       	std	Y+1, r1	; 0x01
    break;
  }
  }
  switch (copyPortLogic) {
 476:	8c 81       	ldd	r24, Y+4	; 0x04
 478:	28 2f       	mov	r18, r24
 47a:	30 e0       	ldi	r19, 0x00	; 0
 47c:	3e 83       	std	Y+6, r19	; 0x06
 47e:	2d 83       	std	Y+5, r18	; 0x05
 480:	8d 81       	ldd	r24, Y+5	; 0x05
 482:	9e 81       	ldd	r25, Y+6	; 0x06
 484:	00 97       	sbiw	r24, 0x00	; 0
 486:	31 f0       	breq	.+12     	; 0x494 <GPIO_initPort+0x92>
 488:	2d 81       	ldd	r18, Y+5	; 0x05
 48a:	3e 81       	ldd	r19, Y+6	; 0x06
 48c:	21 30       	cpi	r18, 0x01	; 1
 48e:	31 05       	cpc	r19, r1
 490:	79 f0       	breq	.+30     	; 0x4b0 <GPIO_initPort+0xae>
 492:	1c c0       	rjmp	.+56     	; 0x4cc <GPIO_initPort+0xca>
  case GPIO_LOW: {
    *port_registers[copyPortName] = 0x00;
 494:	8a 81       	ldd	r24, Y+2	; 0x02
 496:	88 2f       	mov	r24, r24
 498:	90 e0       	ldi	r25, 0x00	; 0
 49a:	88 0f       	add	r24, r24
 49c:	99 1f       	adc	r25, r25
 49e:	fc 01       	movw	r30, r24
 4a0:	e8 59       	subi	r30, 0x98	; 152
 4a2:	ff 4f       	sbci	r31, 0xFF	; 255
 4a4:	01 90       	ld	r0, Z+
 4a6:	f0 81       	ld	r31, Z
 4a8:	e0 2d       	mov	r30, r0
 4aa:	10 82       	st	Z, r1
    ret = GPIO_OK;
 4ac:	19 82       	std	Y+1, r1	; 0x01
 4ae:	0e c0       	rjmp	.+28     	; 0x4cc <GPIO_initPort+0xca>
    break;
  }
  case GPIO_HIGH: {
    *port_registers[copyPortName] = 0xFF;
 4b0:	8a 81       	ldd	r24, Y+2	; 0x02
 4b2:	88 2f       	mov	r24, r24
 4b4:	90 e0       	ldi	r25, 0x00	; 0
 4b6:	88 0f       	add	r24, r24
 4b8:	99 1f       	adc	r25, r25
 4ba:	fc 01       	movw	r30, r24
 4bc:	e8 59       	subi	r30, 0x98	; 152
 4be:	ff 4f       	sbci	r31, 0xFF	; 255
 4c0:	01 90       	ld	r0, Z+
 4c2:	f0 81       	ld	r31, Z
 4c4:	e0 2d       	mov	r30, r0
 4c6:	8f ef       	ldi	r24, 0xFF	; 255
 4c8:	80 83       	st	Z, r24
    ret = GPIO_OK;
 4ca:	19 82       	std	Y+1, r1	; 0x01
    break;
  }
  }
  return ret;
 4cc:	89 81       	ldd	r24, Y+1	; 0x01
}
 4ce:	28 96       	adiw	r28, 0x08	; 8
 4d0:	0f b6       	in	r0, 0x3f	; 63
 4d2:	f8 94       	cli
 4d4:	de bf       	out	0x3e, r29	; 62
 4d6:	0f be       	out	0x3f, r0	; 63
 4d8:	cd bf       	out	0x3d, r28	; 61
 4da:	cf 91       	pop	r28
 4dc:	df 91       	pop	r29
 4de:	08 95       	ret

000004e0 <GPIO_changePortDir>:

EN_GPIO_systemState_t GPIO_changePortDir(EN_GPIO_mcuPorts_t copyPortName,
                                         EN_GPIO_pinDir_t copyNewPortDir) {
 4e0:	df 93       	push	r29
 4e2:	cf 93       	push	r28
 4e4:	00 d0       	rcall	.+0      	; 0x4e6 <GPIO_changePortDir+0x6>
 4e6:	00 d0       	rcall	.+0      	; 0x4e8 <GPIO_changePortDir+0x8>
 4e8:	0f 92       	push	r0
 4ea:	cd b7       	in	r28, 0x3d	; 61
 4ec:	de b7       	in	r29, 0x3e	; 62
 4ee:	8a 83       	std	Y+2, r24	; 0x02
 4f0:	6b 83       	std	Y+3, r22	; 0x03
  EN_GPIO_systemState_t ret = GPIO_NOK;
 4f2:	81 e0       	ldi	r24, 0x01	; 1
 4f4:	89 83       	std	Y+1, r24	; 0x01

  switch (copyNewPortDir) {
 4f6:	8b 81       	ldd	r24, Y+3	; 0x03
 4f8:	28 2f       	mov	r18, r24
 4fa:	30 e0       	ldi	r19, 0x00	; 0
 4fc:	3d 83       	std	Y+5, r19	; 0x05
 4fe:	2c 83       	std	Y+4, r18	; 0x04
 500:	8c 81       	ldd	r24, Y+4	; 0x04
 502:	9d 81       	ldd	r25, Y+5	; 0x05
 504:	00 97       	sbiw	r24, 0x00	; 0
 506:	31 f0       	breq	.+12     	; 0x514 <GPIO_changePortDir+0x34>
 508:	2c 81       	ldd	r18, Y+4	; 0x04
 50a:	3d 81       	ldd	r19, Y+5	; 0x05
 50c:	21 30       	cpi	r18, 0x01	; 1
 50e:	31 05       	cpc	r19, r1
 510:	79 f0       	breq	.+30     	; 0x530 <GPIO_changePortDir+0x50>
 512:	1c c0       	rjmp	.+56     	; 0x54c <GPIO_changePortDir+0x6c>
  case GPIO_INPUT: {
    *ddr_registers[copyPortName] = 0x00;
 514:	8a 81       	ldd	r24, Y+2	; 0x02
 516:	88 2f       	mov	r24, r24
 518:	90 e0       	ldi	r25, 0x00	; 0
 51a:	88 0f       	add	r24, r24
 51c:	99 1f       	adc	r25, r25
 51e:	fc 01       	movw	r30, r24
 520:	e0 5a       	subi	r30, 0xA0	; 160
 522:	ff 4f       	sbci	r31, 0xFF	; 255
 524:	01 90       	ld	r0, Z+
 526:	f0 81       	ld	r31, Z
 528:	e0 2d       	mov	r30, r0
 52a:	10 82       	st	Z, r1
    ret = GPIO_OK;
 52c:	19 82       	std	Y+1, r1	; 0x01
 52e:	0e c0       	rjmp	.+28     	; 0x54c <GPIO_changePortDir+0x6c>
    break;
  }
  case GPIO_OUTPUT: {
    *ddr_registers[copyPortName] = 0xFF;
 530:	8a 81       	ldd	r24, Y+2	; 0x02
 532:	88 2f       	mov	r24, r24
 534:	90 e0       	ldi	r25, 0x00	; 0
 536:	88 0f       	add	r24, r24
 538:	99 1f       	adc	r25, r25
 53a:	fc 01       	movw	r30, r24
 53c:	e0 5a       	subi	r30, 0xA0	; 160
 53e:	ff 4f       	sbci	r31, 0xFF	; 255
 540:	01 90       	ld	r0, Z+
 542:	f0 81       	ld	r31, Z
 544:	e0 2d       	mov	r30, r0
 546:	8f ef       	ldi	r24, 0xFF	; 255
 548:	80 83       	st	Z, r24
    ret = GPIO_OK;
 54a:	19 82       	std	Y+1, r1	; 0x01
    break;
  }
  }
  return ret;
 54c:	89 81       	ldd	r24, Y+1	; 0x01
}
 54e:	0f 90       	pop	r0
 550:	0f 90       	pop	r0
 552:	0f 90       	pop	r0
 554:	0f 90       	pop	r0
 556:	0f 90       	pop	r0
 558:	cf 91       	pop	r28
 55a:	df 91       	pop	r29
 55c:	08 95       	ret

0000055e <GPIO_writePortLogic>:

EN_GPIO_systemState_t GPIO_writePortLogic(EN_GPIO_mcuPorts_t copyPortName,
                                          EN_GPIO_pinLogic_t copyNewPortLogic) {
 55e:	df 93       	push	r29
 560:	cf 93       	push	r28
 562:	00 d0       	rcall	.+0      	; 0x564 <GPIO_writePortLogic+0x6>
 564:	00 d0       	rcall	.+0      	; 0x566 <GPIO_writePortLogic+0x8>
 566:	0f 92       	push	r0
 568:	cd b7       	in	r28, 0x3d	; 61
 56a:	de b7       	in	r29, 0x3e	; 62
 56c:	8a 83       	std	Y+2, r24	; 0x02
 56e:	6b 83       	std	Y+3, r22	; 0x03
  EN_GPIO_systemState_t ret = GPIO_NOK;
 570:	81 e0       	ldi	r24, 0x01	; 1
 572:	89 83       	std	Y+1, r24	; 0x01
  switch (copyNewPortLogic) {
 574:	8b 81       	ldd	r24, Y+3	; 0x03
 576:	28 2f       	mov	r18, r24
 578:	30 e0       	ldi	r19, 0x00	; 0
 57a:	3d 83       	std	Y+5, r19	; 0x05
 57c:	2c 83       	std	Y+4, r18	; 0x04
 57e:	8c 81       	ldd	r24, Y+4	; 0x04
 580:	9d 81       	ldd	r25, Y+5	; 0x05
 582:	00 97       	sbiw	r24, 0x00	; 0
 584:	31 f0       	breq	.+12     	; 0x592 <GPIO_writePortLogic+0x34>
 586:	2c 81       	ldd	r18, Y+4	; 0x04
 588:	3d 81       	ldd	r19, Y+5	; 0x05
 58a:	21 30       	cpi	r18, 0x01	; 1
 58c:	31 05       	cpc	r19, r1
 58e:	79 f0       	breq	.+30     	; 0x5ae <GPIO_writePortLogic+0x50>
 590:	1c c0       	rjmp	.+56     	; 0x5ca <GPIO_writePortLogic+0x6c>
  case GPIO_LOW: {
    *port_registers[copyPortName] = 0x00;
 592:	8a 81       	ldd	r24, Y+2	; 0x02
 594:	88 2f       	mov	r24, r24
 596:	90 e0       	ldi	r25, 0x00	; 0
 598:	88 0f       	add	r24, r24
 59a:	99 1f       	adc	r25, r25
 59c:	fc 01       	movw	r30, r24
 59e:	e8 59       	subi	r30, 0x98	; 152
 5a0:	ff 4f       	sbci	r31, 0xFF	; 255
 5a2:	01 90       	ld	r0, Z+
 5a4:	f0 81       	ld	r31, Z
 5a6:	e0 2d       	mov	r30, r0
 5a8:	10 82       	st	Z, r1
    ret = GPIO_OK;
 5aa:	19 82       	std	Y+1, r1	; 0x01
 5ac:	0e c0       	rjmp	.+28     	; 0x5ca <GPIO_writePortLogic+0x6c>
    break;
  }
  case GPIO_HIGH: {
    *port_registers[copyPortName] = 0xFF;
 5ae:	8a 81       	ldd	r24, Y+2	; 0x02
 5b0:	88 2f       	mov	r24, r24
 5b2:	90 e0       	ldi	r25, 0x00	; 0
 5b4:	88 0f       	add	r24, r24
 5b6:	99 1f       	adc	r25, r25
 5b8:	fc 01       	movw	r30, r24
 5ba:	e8 59       	subi	r30, 0x98	; 152
 5bc:	ff 4f       	sbci	r31, 0xFF	; 255
 5be:	01 90       	ld	r0, Z+
 5c0:	f0 81       	ld	r31, Z
 5c2:	e0 2d       	mov	r30, r0
 5c4:	8f ef       	ldi	r24, 0xFF	; 255
 5c6:	80 83       	st	Z, r24
    ret = GPIO_OK;
 5c8:	19 82       	std	Y+1, r1	; 0x01
    break;
  }
  }
  return ret;
 5ca:	89 81       	ldd	r24, Y+1	; 0x01
}
 5cc:	0f 90       	pop	r0
 5ce:	0f 90       	pop	r0
 5d0:	0f 90       	pop	r0
 5d2:	0f 90       	pop	r0
 5d4:	0f 90       	pop	r0
 5d6:	cf 91       	pop	r28
 5d8:	df 91       	pop	r29
 5da:	08 95       	ret

000005dc <GPIO_readPortLogic>:

EN_GPIO_systemState_t
GPIO_readPortLogic(EN_GPIO_mcuPorts_t copyPortName,
                   EN_GPIO_pinLogic_t *retCurrentPortLogic) {
 5dc:	df 93       	push	r29
 5de:	cf 93       	push	r28
 5e0:	00 d0       	rcall	.+0      	; 0x5e2 <GPIO_readPortLogic+0x6>
 5e2:	00 d0       	rcall	.+0      	; 0x5e4 <GPIO_readPortLogic+0x8>
 5e4:	cd b7       	in	r28, 0x3d	; 61
 5e6:	de b7       	in	r29, 0x3e	; 62
 5e8:	8a 83       	std	Y+2, r24	; 0x02
 5ea:	7c 83       	std	Y+4, r23	; 0x04
 5ec:	6b 83       	std	Y+3, r22	; 0x03
  EN_GPIO_systemState_t ret = GPIO_NOK;
 5ee:	81 e0       	ldi	r24, 0x01	; 1
 5f0:	89 83       	std	Y+1, r24	; 0x01

  *retCurrentPortLogic = *pin_registers[copyPortName];
 5f2:	8a 81       	ldd	r24, Y+2	; 0x02
 5f4:	88 2f       	mov	r24, r24
 5f6:	90 e0       	ldi	r25, 0x00	; 0
 5f8:	88 0f       	add	r24, r24
 5fa:	99 1f       	adc	r25, r25
 5fc:	fc 01       	movw	r30, r24
 5fe:	e0 59       	subi	r30, 0x90	; 144
 600:	ff 4f       	sbci	r31, 0xFF	; 255
 602:	01 90       	ld	r0, Z+
 604:	f0 81       	ld	r31, Z
 606:	e0 2d       	mov	r30, r0
 608:	80 81       	ld	r24, Z
 60a:	eb 81       	ldd	r30, Y+3	; 0x03
 60c:	fc 81       	ldd	r31, Y+4	; 0x04
 60e:	80 83       	st	Z, r24
  ret = GPIO_OK;
 610:	19 82       	std	Y+1, r1	; 0x01
  return ret;
 612:	89 81       	ldd	r24, Y+1	; 0x01
}
 614:	0f 90       	pop	r0
 616:	0f 90       	pop	r0
 618:	0f 90       	pop	r0
 61a:	0f 90       	pop	r0
 61c:	cf 91       	pop	r28
 61e:	df 91       	pop	r29
 620:	08 95       	ret

00000622 <GPIO_togglePortLogic>:

EN_GPIO_systemState_t GPIO_togglePortLogic(EN_GPIO_mcuPorts_t copyPortName) {
 622:	df 93       	push	r29
 624:	cf 93       	push	r28
 626:	00 d0       	rcall	.+0      	; 0x628 <GPIO_togglePortLogic+0x6>
 628:	cd b7       	in	r28, 0x3d	; 61
 62a:	de b7       	in	r29, 0x3e	; 62
 62c:	8a 83       	std	Y+2, r24	; 0x02
  EN_GPIO_systemState_t ret = GPIO_NOK;
 62e:	81 e0       	ldi	r24, 0x01	; 1
 630:	89 83       	std	Y+1, r24	; 0x01
  *ddr_registers[copyPortName] ^= *ddr_registers[copyPortName];
 632:	8a 81       	ldd	r24, Y+2	; 0x02
 634:	88 2f       	mov	r24, r24
 636:	90 e0       	ldi	r25, 0x00	; 0
 638:	88 0f       	add	r24, r24
 63a:	99 1f       	adc	r25, r25
 63c:	fc 01       	movw	r30, r24
 63e:	e0 5a       	subi	r30, 0xA0	; 160
 640:	ff 4f       	sbci	r31, 0xFF	; 255
 642:	a0 81       	ld	r26, Z
 644:	b1 81       	ldd	r27, Z+1	; 0x01
 646:	8a 81       	ldd	r24, Y+2	; 0x02
 648:	88 2f       	mov	r24, r24
 64a:	90 e0       	ldi	r25, 0x00	; 0
 64c:	88 0f       	add	r24, r24
 64e:	99 1f       	adc	r25, r25
 650:	fc 01       	movw	r30, r24
 652:	e0 5a       	subi	r30, 0xA0	; 160
 654:	ff 4f       	sbci	r31, 0xFF	; 255
 656:	01 90       	ld	r0, Z+
 658:	f0 81       	ld	r31, Z
 65a:	e0 2d       	mov	r30, r0
 65c:	20 81       	ld	r18, Z
 65e:	8a 81       	ldd	r24, Y+2	; 0x02
 660:	88 2f       	mov	r24, r24
 662:	90 e0       	ldi	r25, 0x00	; 0
 664:	88 0f       	add	r24, r24
 666:	99 1f       	adc	r25, r25
 668:	fc 01       	movw	r30, r24
 66a:	e0 5a       	subi	r30, 0xA0	; 160
 66c:	ff 4f       	sbci	r31, 0xFF	; 255
 66e:	01 90       	ld	r0, Z+
 670:	f0 81       	ld	r31, Z
 672:	e0 2d       	mov	r30, r0
 674:	80 81       	ld	r24, Z
 676:	82 27       	eor	r24, r18
 678:	8c 93       	st	X, r24
  ret = GPIO_OK;
 67a:	19 82       	std	Y+1, r1	; 0x01
  return ret;
 67c:	89 81       	ldd	r24, Y+1	; 0x01
}
 67e:	0f 90       	pop	r0
 680:	0f 90       	pop	r0
 682:	cf 91       	pop	r28
 684:	df 91       	pop	r29
 686:	08 95       	ret

00000688 <LED_init>:
// Date          : 1 Aug 2023 */ GitHub        : https://github.com/sherifkhadr
/*************************************************************************/

#include "led_interface.h"

EN_LED_systemStates_t LED_init(ST_LED_cfg_t const *ST_ptrLedInstance) {
 688:	df 93       	push	r29
 68a:	cf 93       	push	r28
 68c:	cd b7       	in	r28, 0x3d	; 61
 68e:	de b7       	in	r29, 0x3e	; 62
 690:	28 97       	sbiw	r28, 0x08	; 8
 692:	0f b6       	in	r0, 0x3f	; 63
 694:	f8 94       	cli
 696:	de bf       	out	0x3e, r29	; 62
 698:	0f be       	out	0x3f, r0	; 63
 69a:	cd bf       	out	0x3d, r28	; 61
 69c:	98 87       	std	Y+8, r25	; 0x08
 69e:	8f 83       	std	Y+7, r24	; 0x07
  EN_LED_systemStates_t ledRet = LED_NOK;
 6a0:	81 e0       	ldi	r24, 0x01	; 1
 6a2:	8a 83       	std	Y+2, r24	; 0x02
  EN_GPIO_systemState_t gpioRet = GPIO_NOK;
 6a4:	81 e0       	ldi	r24, 0x01	; 1
 6a6:	89 83       	std	Y+1, r24	; 0x01
  if (PTR_NULL != ST_ptrLedInstance) {
 6a8:	8f 81       	ldd	r24, Y+7	; 0x07
 6aa:	98 85       	ldd	r25, Y+8	; 0x08
 6ac:	00 97       	sbiw	r24, 0x00	; 0
 6ae:	d9 f0       	breq	.+54     	; 0x6e6 <LED_init+0x5e>

    ST_GPIO_cfg_t copyOfLedInstance = {
        .logicOnPin = (EN_GPIO_pinLogic_t)ST_ptrLedInstance->ledDefaultState,
        .pinDirection = GPIO_OUTPUT,
        .pinNumber = ST_ptrLedInstance->ledPinNumber,
        .portName = ST_ptrLedInstance->ledPortName};
 6b0:	ef 81       	ldd	r30, Y+7	; 0x07
 6b2:	f8 85       	ldd	r31, Y+8	; 0x08
 6b4:	81 81       	ldd	r24, Z+1	; 0x01
 6b6:	ef 81       	ldd	r30, Y+7	; 0x07
 6b8:	f8 85       	ldd	r31, Y+8	; 0x08
 6ba:	92 81       	ldd	r25, Z+2	; 0x02
 6bc:	ef 81       	ldd	r30, Y+7	; 0x07
 6be:	f8 85       	ldd	r31, Y+8	; 0x08
 6c0:	20 81       	ld	r18, Z
 6c2:	8b 83       	std	Y+3, r24	; 0x03
 6c4:	9c 83       	std	Y+4, r25	; 0x04
 6c6:	81 e0       	ldi	r24, 0x01	; 1
 6c8:	8d 83       	std	Y+5, r24	; 0x05
 6ca:	2e 83       	std	Y+6, r18	; 0x06
    gpioRet = GPIO_initPin(&copyOfLedInstance);
 6cc:	ce 01       	movw	r24, r28
 6ce:	03 96       	adiw	r24, 0x03	; 3
 6d0:	0e 94 49 00 	call	0x92	; 0x92 <GPIO_initPin>
 6d4:	89 83       	std	Y+1, r24	; 0x01
    if (GPIO_OK == gpioRet) {
 6d6:	89 81       	ldd	r24, Y+1	; 0x01
 6d8:	88 23       	and	r24, r24
 6da:	11 f4       	brne	.+4      	; 0x6e0 <LED_init+0x58>
      ledRet = LED_OK;
 6dc:	1a 82       	std	Y+2, r1	; 0x02
 6de:	05 c0       	rjmp	.+10     	; 0x6ea <LED_init+0x62>
    } else {
      ledRet = LED_NOK;
 6e0:	81 e0       	ldi	r24, 0x01	; 1
 6e2:	8a 83       	std	Y+2, r24	; 0x02
 6e4:	02 c0       	rjmp	.+4      	; 0x6ea <LED_init+0x62>
    }
  } else {
    ledRet = LED_PTR_NULL;
 6e6:	82 e0       	ldi	r24, 0x02	; 2
 6e8:	8a 83       	std	Y+2, r24	; 0x02
  }
  return ledRet;
 6ea:	8a 81       	ldd	r24, Y+2	; 0x02
}
 6ec:	28 96       	adiw	r28, 0x08	; 8
 6ee:	0f b6       	in	r0, 0x3f	; 63
 6f0:	f8 94       	cli
 6f2:	de bf       	out	0x3e, r29	; 62
 6f4:	0f be       	out	0x3f, r0	; 63
 6f6:	cd bf       	out	0x3d, r28	; 61
 6f8:	cf 91       	pop	r28
 6fa:	df 91       	pop	r29
 6fc:	08 95       	ret

000006fe <LED_turnOn>:
EN_LED_systemStates_t LED_turnOn(ST_LED_cfg_t const *ST_ptrLedInstance) {
 6fe:	df 93       	push	r29
 700:	cf 93       	push	r28
 702:	cd b7       	in	r28, 0x3d	; 61
 704:	de b7       	in	r29, 0x3e	; 62
 706:	28 97       	sbiw	r28, 0x08	; 8
 708:	0f b6       	in	r0, 0x3f	; 63
 70a:	f8 94       	cli
 70c:	de bf       	out	0x3e, r29	; 62
 70e:	0f be       	out	0x3f, r0	; 63
 710:	cd bf       	out	0x3d, r28	; 61
 712:	98 87       	std	Y+8, r25	; 0x08
 714:	8f 83       	std	Y+7, r24	; 0x07
  EN_LED_systemStates_t ledRet = LED_NOK;
 716:	81 e0       	ldi	r24, 0x01	; 1
 718:	8a 83       	std	Y+2, r24	; 0x02
  EN_GPIO_systemState_t gpioRet = GPIO_NOK;
 71a:	81 e0       	ldi	r24, 0x01	; 1
 71c:	89 83       	std	Y+1, r24	; 0x01
  if (PTR_NULL != ST_ptrLedInstance) {
 71e:	8f 81       	ldd	r24, Y+7	; 0x07
 720:	98 85       	ldd	r25, Y+8	; 0x08
 722:	00 97       	sbiw	r24, 0x00	; 0
 724:	e1 f0       	breq	.+56     	; 0x75e <LED_turnOn+0x60>

    ST_GPIO_cfg_t copyOfLedInstance = {
        .logicOnPin = (EN_GPIO_pinLogic_t)ST_ptrLedInstance->ledDefaultState,
        .pinDirection = GPIO_OUTPUT,
        .pinNumber = ST_ptrLedInstance->ledPinNumber,
        .portName = ST_ptrLedInstance->ledPortName};
 726:	ef 81       	ldd	r30, Y+7	; 0x07
 728:	f8 85       	ldd	r31, Y+8	; 0x08
 72a:	81 81       	ldd	r24, Z+1	; 0x01
 72c:	ef 81       	ldd	r30, Y+7	; 0x07
 72e:	f8 85       	ldd	r31, Y+8	; 0x08
 730:	92 81       	ldd	r25, Z+2	; 0x02
 732:	ef 81       	ldd	r30, Y+7	; 0x07
 734:	f8 85       	ldd	r31, Y+8	; 0x08
 736:	20 81       	ld	r18, Z
 738:	8b 83       	std	Y+3, r24	; 0x03
 73a:	9c 83       	std	Y+4, r25	; 0x04
 73c:	81 e0       	ldi	r24, 0x01	; 1
 73e:	8d 83       	std	Y+5, r24	; 0x05
 740:	2e 83       	std	Y+6, r18	; 0x06
    gpioRet = GPIO_writePinLogic(&copyOfLedInstance, GPIO_HIGH);
 742:	ce 01       	movw	r24, r28
 744:	03 96       	adiw	r24, 0x03	; 3
 746:	61 e0       	ldi	r22, 0x01	; 1
 748:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <GPIO_writePinLogic>
 74c:	89 83       	std	Y+1, r24	; 0x01
    if (GPIO_OK == gpioRet) {
 74e:	89 81       	ldd	r24, Y+1	; 0x01
 750:	88 23       	and	r24, r24
 752:	11 f4       	brne	.+4      	; 0x758 <LED_turnOn+0x5a>
      ledRet = LED_OK;
 754:	1a 82       	std	Y+2, r1	; 0x02
 756:	05 c0       	rjmp	.+10     	; 0x762 <LED_turnOn+0x64>
    } else {
      ledRet = LED_NOK;
 758:	81 e0       	ldi	r24, 0x01	; 1
 75a:	8a 83       	std	Y+2, r24	; 0x02
 75c:	02 c0       	rjmp	.+4      	; 0x762 <LED_turnOn+0x64>
    }
  } else {
    ledRet = LED_PTR_NULL;
 75e:	82 e0       	ldi	r24, 0x02	; 2
 760:	8a 83       	std	Y+2, r24	; 0x02
  }
  return ledRet;
 762:	8a 81       	ldd	r24, Y+2	; 0x02
}
 764:	28 96       	adiw	r28, 0x08	; 8
 766:	0f b6       	in	r0, 0x3f	; 63
 768:	f8 94       	cli
 76a:	de bf       	out	0x3e, r29	; 62
 76c:	0f be       	out	0x3f, r0	; 63
 76e:	cd bf       	out	0x3d, r28	; 61
 770:	cf 91       	pop	r28
 772:	df 91       	pop	r29
 774:	08 95       	ret

00000776 <LED_turnOff>:
EN_LED_systemStates_t LED_turnOff(ST_LED_cfg_t const *ST_ptrLedInstance) {
 776:	df 93       	push	r29
 778:	cf 93       	push	r28
 77a:	cd b7       	in	r28, 0x3d	; 61
 77c:	de b7       	in	r29, 0x3e	; 62
 77e:	28 97       	sbiw	r28, 0x08	; 8
 780:	0f b6       	in	r0, 0x3f	; 63
 782:	f8 94       	cli
 784:	de bf       	out	0x3e, r29	; 62
 786:	0f be       	out	0x3f, r0	; 63
 788:	cd bf       	out	0x3d, r28	; 61
 78a:	98 87       	std	Y+8, r25	; 0x08
 78c:	8f 83       	std	Y+7, r24	; 0x07
  EN_LED_systemStates_t ledRet = LED_NOK;
 78e:	81 e0       	ldi	r24, 0x01	; 1
 790:	8a 83       	std	Y+2, r24	; 0x02
  EN_GPIO_systemState_t gpioRet = GPIO_NOK;
 792:	81 e0       	ldi	r24, 0x01	; 1
 794:	89 83       	std	Y+1, r24	; 0x01
  if (PTR_NULL != ST_ptrLedInstance) {
 796:	8f 81       	ldd	r24, Y+7	; 0x07
 798:	98 85       	ldd	r25, Y+8	; 0x08
 79a:	00 97       	sbiw	r24, 0x00	; 0
 79c:	e1 f0       	breq	.+56     	; 0x7d6 <LED_turnOff+0x60>

    ST_GPIO_cfg_t copyOfLedInstance = {
        .logicOnPin = (EN_GPIO_pinLogic_t)ST_ptrLedInstance->ledDefaultState,
        .pinDirection = GPIO_OUTPUT,
        .pinNumber = ST_ptrLedInstance->ledPinNumber,
        .portName = ST_ptrLedInstance->ledPortName};
 79e:	ef 81       	ldd	r30, Y+7	; 0x07
 7a0:	f8 85       	ldd	r31, Y+8	; 0x08
 7a2:	81 81       	ldd	r24, Z+1	; 0x01
 7a4:	ef 81       	ldd	r30, Y+7	; 0x07
 7a6:	f8 85       	ldd	r31, Y+8	; 0x08
 7a8:	92 81       	ldd	r25, Z+2	; 0x02
 7aa:	ef 81       	ldd	r30, Y+7	; 0x07
 7ac:	f8 85       	ldd	r31, Y+8	; 0x08
 7ae:	20 81       	ld	r18, Z
 7b0:	8b 83       	std	Y+3, r24	; 0x03
 7b2:	9c 83       	std	Y+4, r25	; 0x04
 7b4:	81 e0       	ldi	r24, 0x01	; 1
 7b6:	8d 83       	std	Y+5, r24	; 0x05
 7b8:	2e 83       	std	Y+6, r18	; 0x06
    gpioRet = GPIO_writePinLogic(&copyOfLedInstance, GPIO_LOW);
 7ba:	ce 01       	movw	r24, r28
 7bc:	03 96       	adiw	r24, 0x03	; 3
 7be:	60 e0       	ldi	r22, 0x00	; 0
 7c0:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <GPIO_writePinLogic>
 7c4:	89 83       	std	Y+1, r24	; 0x01
    if (GPIO_OK == gpioRet) {
 7c6:	89 81       	ldd	r24, Y+1	; 0x01
 7c8:	88 23       	and	r24, r24
 7ca:	11 f4       	brne	.+4      	; 0x7d0 <LED_turnOff+0x5a>
      ledRet = LED_OK;
 7cc:	1a 82       	std	Y+2, r1	; 0x02
 7ce:	05 c0       	rjmp	.+10     	; 0x7da <LED_turnOff+0x64>
    } else {
      ledRet = LED_NOK;
 7d0:	81 e0       	ldi	r24, 0x01	; 1
 7d2:	8a 83       	std	Y+2, r24	; 0x02
 7d4:	02 c0       	rjmp	.+4      	; 0x7da <LED_turnOff+0x64>
    }
  } else {
    ledRet = LED_PTR_NULL;
 7d6:	82 e0       	ldi	r24, 0x02	; 2
 7d8:	8a 83       	std	Y+2, r24	; 0x02
  }
  return ledRet;
 7da:	8a 81       	ldd	r24, Y+2	; 0x02
}
 7dc:	28 96       	adiw	r28, 0x08	; 8
 7de:	0f b6       	in	r0, 0x3f	; 63
 7e0:	f8 94       	cli
 7e2:	de bf       	out	0x3e, r29	; 62
 7e4:	0f be       	out	0x3f, r0	; 63
 7e6:	cd bf       	out	0x3d, r28	; 61
 7e8:	cf 91       	pop	r28
 7ea:	df 91       	pop	r29
 7ec:	08 95       	ret

000007ee <LED_toggle>:
EN_LED_systemStates_t LED_toggle(ST_LED_cfg_t const *ST_ptrLedInstance) {
 7ee:	df 93       	push	r29
 7f0:	cf 93       	push	r28
 7f2:	cd b7       	in	r28, 0x3d	; 61
 7f4:	de b7       	in	r29, 0x3e	; 62
 7f6:	28 97       	sbiw	r28, 0x08	; 8
 7f8:	0f b6       	in	r0, 0x3f	; 63
 7fa:	f8 94       	cli
 7fc:	de bf       	out	0x3e, r29	; 62
 7fe:	0f be       	out	0x3f, r0	; 63
 800:	cd bf       	out	0x3d, r28	; 61
 802:	98 87       	std	Y+8, r25	; 0x08
 804:	8f 83       	std	Y+7, r24	; 0x07
  EN_LED_systemStates_t ledRet = LED_NOK;
 806:	81 e0       	ldi	r24, 0x01	; 1
 808:	8a 83       	std	Y+2, r24	; 0x02
  EN_GPIO_systemState_t gpioRet = GPIO_NOK;
 80a:	81 e0       	ldi	r24, 0x01	; 1
 80c:	89 83       	std	Y+1, r24	; 0x01
  if (PTR_NULL != ST_ptrLedInstance) {
 80e:	8f 81       	ldd	r24, Y+7	; 0x07
 810:	98 85       	ldd	r25, Y+8	; 0x08
 812:	00 97       	sbiw	r24, 0x00	; 0
 814:	d9 f0       	breq	.+54     	; 0x84c <LED_toggle+0x5e>

    ST_GPIO_cfg_t copyOfLedInstance = {
        .logicOnPin = (EN_GPIO_pinLogic_t)ST_ptrLedInstance->ledDefaultState,
        .pinDirection = GPIO_OUTPUT,
        .pinNumber = ST_ptrLedInstance->ledPinNumber,
        .portName = ST_ptrLedInstance->ledPortName};
 816:	ef 81       	ldd	r30, Y+7	; 0x07
 818:	f8 85       	ldd	r31, Y+8	; 0x08
 81a:	81 81       	ldd	r24, Z+1	; 0x01
 81c:	ef 81       	ldd	r30, Y+7	; 0x07
 81e:	f8 85       	ldd	r31, Y+8	; 0x08
 820:	92 81       	ldd	r25, Z+2	; 0x02
 822:	ef 81       	ldd	r30, Y+7	; 0x07
 824:	f8 85       	ldd	r31, Y+8	; 0x08
 826:	20 81       	ld	r18, Z
 828:	8b 83       	std	Y+3, r24	; 0x03
 82a:	9c 83       	std	Y+4, r25	; 0x04
 82c:	81 e0       	ldi	r24, 0x01	; 1
 82e:	8d 83       	std	Y+5, r24	; 0x05
 830:	2e 83       	std	Y+6, r18	; 0x06
    gpioRet = GPIO_togglePinLogic(&copyOfLedInstance);
 832:	ce 01       	movw	r24, r28
 834:	03 96       	adiw	r24, 0x03	; 3
 836:	0e 94 be 01 	call	0x37c	; 0x37c <GPIO_togglePinLogic>
 83a:	89 83       	std	Y+1, r24	; 0x01
    if (GPIO_OK == gpioRet) {
 83c:	89 81       	ldd	r24, Y+1	; 0x01
 83e:	88 23       	and	r24, r24
 840:	11 f4       	brne	.+4      	; 0x846 <LED_toggle+0x58>
      ledRet = LED_OK;
 842:	1a 82       	std	Y+2, r1	; 0x02
 844:	05 c0       	rjmp	.+10     	; 0x850 <LED_toggle+0x62>
    } else {
      ledRet = LED_NOK;
 846:	81 e0       	ldi	r24, 0x01	; 1
 848:	8a 83       	std	Y+2, r24	; 0x02
 84a:	02 c0       	rjmp	.+4      	; 0x850 <LED_toggle+0x62>
    }
  } else {
    ledRet = LED_PTR_NULL;
 84c:	82 e0       	ldi	r24, 0x02	; 2
 84e:	8a 83       	std	Y+2, r24	; 0x02
  }
  return ledRet;
 850:	8a 81       	ldd	r24, Y+2	; 0x02
 852:	28 96       	adiw	r28, 0x08	; 8
 854:	0f b6       	in	r0, 0x3f	; 63
 856:	f8 94       	cli
 858:	de bf       	out	0x3e, r29	; 62
 85a:	0f be       	out	0x3f, r0	; 63
 85c:	cd bf       	out	0x3d, r28	; 61
 85e:	cf 91       	pop	r28
 860:	df 91       	pop	r29
 862:	08 95       	ret

00000864 <appInit>:

ST_LED_cfg_t pinA0Led = {.ledDefaultState = LED_STATUES_OFF,
                         .ledPortName = GPIO_PORTA,
                         .ledPinNumber = GPIO_PIN0};

void appInit() { LED_init(&pinA0Led); }
 864:	df 93       	push	r29
 866:	cf 93       	push	r28
 868:	cd b7       	in	r28, 0x3d	; 61
 86a:	de b7       	in	r29, 0x3e	; 62
 86c:	88 e7       	ldi	r24, 0x78	; 120
 86e:	90 e0       	ldi	r25, 0x00	; 0
 870:	0e 94 44 03 	call	0x688	; 0x688 <LED_init>
 874:	cf 91       	pop	r28
 876:	df 91       	pop	r29
 878:	08 95       	ret

0000087a <appMain>:
void appMain() { LED_turnOn(&pinA0Led); }
 87a:	df 93       	push	r29
 87c:	cf 93       	push	r28
 87e:	cd b7       	in	r28, 0x3d	; 61
 880:	de b7       	in	r29, 0x3e	; 62
 882:	88 e7       	ldi	r24, 0x78	; 120
 884:	90 e0       	ldi	r25, 0x00	; 0
 886:	0e 94 7f 03 	call	0x6fe	; 0x6fe <LED_turnOn>
 88a:	cf 91       	pop	r28
 88c:	df 91       	pop	r29
 88e:	08 95       	ret

00000890 <main>:
// GitHub         : https://github.com/sherifkhadr
/*************************************************************************/

#include "APPLICATION/app.h"

int main(void) {
 890:	df 93       	push	r29
 892:	cf 93       	push	r28
 894:	cd b7       	in	r28, 0x3d	; 61
 896:	de b7       	in	r29, 0x3e	; 62

  appInit();
 898:	0e 94 32 04 	call	0x864	; 0x864 <appInit>
  appMain();
 89c:	0e 94 3d 04 	call	0x87a	; 0x87a <appMain>
 8a0:	ff cf       	rjmp	.-2      	; 0x8a0 <main+0x10>

000008a2 <_exit>:
 8a2:	f8 94       	cli

000008a4 <__stop_program>:
 8a4:	ff cf       	rjmp	.-2      	; 0x8a4 <__stop_program>
